<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klondike Solitaire</title>
    <style>
body {
    background-color: #2e3b4e; /* Dark background for better contrast */
    font-family: Arial, sans-serif;
    color: #ffffff;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

.klondike-solitaire {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    width: 80%; /* Center the content with some margins */
    max-width: 1200px;
    background-color: #3f4d62; /* Slightly darker than the body background */
    border-radius: 15px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

.top-row {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 20px;
}

.stock-waste, .foundations {
    display: flex;
    gap: 20px;
}

.tableau {
    display: flex;
    gap: 20px;
}

.pile {
    width: 100px;
    height: 140px;
    border: 2px solid #606f8b; /* A soft border color */
    border-radius: 10px;
    position: relative;
    background-color: #3b4558; /* Background for empty piles */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.foundation, .tableau-pile {
    background-color: #4a5568; /* Unified background color */
}

.tableau-pile {
    height: 300px;
}

.card {
    width: 100px;
    height: 140px;
    border: 1px solid #333;
    border-radius: 10px;
    position: absolute;
    background-color: #ffffff; /* White background for face-up cards */
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Adds a shadow for a 3D effect */
    transition: transform 0.2s ease;
}

.card:hover {
    transform: scale(1.05); /* Slight zoom effect on hover */
}

.card.face-down {
    background-color: #6c757d; /* Same as before, face-down card color */
    border: 1px solid #555;
}

.card .value {
    font-size: 24px;
    font-weight: bold;
}

.card .value small {
    font-size: 18px;
}

.card .value.red {
    color: red;
}

.card .value.black {
    color: black;
}
    </style>
</head>
<body>
    <div class="klondike-solitaire">
        <div class="top-row">
            <div class="stock-waste">
                <div id="stock" class="pile"></div>
                <div id="waste" class="pile"></div>
            </div>
            <div class="foundations">
                <div id="foundation-0" class="pile foundation"></div>
                <div id="foundation-1" class="pile foundation"></div>
                <div id="foundation-2" class="pile foundation"></div>
                <div id="foundation-3" class="pile foundation"></div>
            </div>
        </div>
        <div class="tableau">
            <div id="tableau-0" class="pile tableau-pile"></div>
            <div id="tableau-1" class="pile tableau-pile"></div>
            <div id="tableau-2" class="pile tableau-pile"></div>
            <div id="tableau-3" class="pile tableau-pile"></div>
            <div id="tableau-4" class="pile tableau-pile"></div>
            <div id="tableau-5" class="pile tableau-pile"></div>
            <div id="tableau-6" class="pile tableau-pile"></div>
        </div>
    </div>
    <script>
const SUITS = ['♠', '♥', '♦', '♣'];
const VALUES = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

let stock = [];
let waste = [];
let foundations = [[], [], [], []];
let tableau = [[], [], [], [], [], [], []];

function createDeck() {
    const deck = [];
    for (const suit of SUITS) {
        for (const value of VALUES) {
            deck.push({ suit, value });
        }
    }
    return deck;
}

function shuffleDeck(deck) {
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
}

function createCardElement(card, faceUp, draggable = true) {
    const cardElement = document.createElement('div');
    cardElement.className = `card ${faceUp ? 'face-up' : 'face-down'}`;
    cardElement.draggable = draggable;

    if (faceUp) {
        const valueElement = document.createElement('div');
        valueElement.className = `value ${['♥', '♦'].includes(card.suit) ? 'red' : 'black'}`;
        valueElement.innerHTML = `${card.value}<small>${card.suit}</small>`;
        cardElement.appendChild(valueElement);
    }

    cardElement.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', JSON.stringify(card));
    });

    return cardElement;
}

function renderPile(pile, elementId, faceUp = false) {
    const pileElement = document.getElementById(elementId);
    pileElement.innerHTML = '';
    pile.forEach((card, index) => {
        const cardElement = createCardElement(card, faceUp);
        cardElement.style.top = `${index * 20}px`;
        pileElement.appendChild(cardElement);
    });
}

function renderTableau() {
    tableau.forEach((pile, index) => {
        const pileElement = document.getElementById(`tableau-${index}`);
        pileElement.innerHTML = '';
        pile.forEach((card, cardIndex) => {
            const cardElement = createCardElement(card, cardIndex === pile.length - 1);
            cardElement.style.top = `${cardIndex * 20}px`;
            pileElement.appendChild(cardElement);
        });
    });
}

function moveToWaste() {
    if (stock.length > 0) {
        const card = stock.pop();
        waste.push(card);
    } else {
        stock = waste.reverse();
        waste = [];
    }
    renderPiles();
}

function renderPiles() {
    renderPile(stock, 'stock');
    renderPile(waste, 'waste', true);
    foundations.forEach((foundation, index) => {
        renderPile(foundation, `foundation-${index}`, true);
    });
    renderTableau();
}

function getCardValue(card) {
    return VALUES.indexOf(card.value);
}

function canAddToFoundation(card, foundation) {
    if (foundation.length === 0) {
        return card.value === 'A';
    }
    const topCard = foundation[foundation.length - 1];
    return card.suit === topCard.suit && getCardValue(card) === getCardValue(topCard) + 1;
}

function canAddToTableau(card, tableauPile) {
    if (tableauPile.length === 0) {
        return card.value === 'K';
    }
    const topCard = tableauPile[tableauPile.length - 1];
    return ['♠', '♣'].includes(card.suit) !== ['♠', '♣'].includes(topCard.suit) &&
           getCardValue(card) === getCardValue(topCard) - 1;
}

function findCard(card) {
    for (let i = 0; i < tableau.length; i++) {
        const index = tableau[i].findIndex(c => c.suit === card.suit && c.value === card.value);
        if (index !== -1) {
            return { pile: tableau[i], index, type: 'tableau', pileIndex: i };
        }
    }
    const wasteIndex = waste.findIndex(c => c.suit === card.suit && c.value === card.value);
    if (wasteIndex !== -1) {
        return { pile: waste, index: wasteIndex, type: 'waste' };
    }
    for (let i = 0; i < foundations.length; i++) {
        const index = foundations[i].findIndex(c => c.suit === card.suit && c.value === card.value);
        if (index !== -1) {
            return { pile: foundations[i], index, type: 'foundation', pileIndex: i };
        }
    }
    return null;
}

function handleDrop(e, targetPile) {
    e.preventDefault();
    const cardData = JSON.parse(e.dataTransfer.getData('text/plain'));
    const sourceInfo = findCard(cardData);

    if (!sourceInfo) return;

    let cardsToMove = sourceInfo.pile.slice(sourceInfo.index);

    if (targetPile.startsWith('foundation')) {
        const foundationIndex = parseInt(targetPile.split('-')[1]);
        if (cardsToMove.length === 1 && canAddToFoundation(cardsToMove[0], foundations[foundationIndex])) {
            foundations[foundationIndex].push(cardsToMove[0]);
            sourceInfo.pile.splice(sourceInfo.index, 1);
        }
    } else if (targetPile.startsWith('tableau')) {
        const tableauIndex = parseInt(targetPile.split('-')[1]);
        if (canAddToTableau(cardsToMove[0], tableau[tableauIndex])) {
            tableau[tableauIndex].push(...cardsToMove);
            sourceInfo.pile.splice(sourceInfo.index);
        }
    }

    if (sourceInfo.type === 'tableau' && sourceInfo.index > 0) {
        tableau[sourceInfo.pileIndex][sourceInfo.index - 1].faceUp = true;
    }

    renderPiles();
}

function initGame() {
    stock = createDeck();
    shuffleDeck(stock);
    waste = [];
    foundations = [[], [], [], []];
    tableau = Array(7).fill().map(() => []);

    // Deal cards to tableau
    for (let i = 0; i < 7; i++) {
        for (let j = i; j < 7; j++) {
            tableau[j].push(stock.pop());
        }
        tableau[i][tableau[i].length - 1].faceUp = true;
    }

    renderPiles();

    const stockElement = document.getElementById('stock');
    stockElement.addEventListener('click', moveToWaste);

    const wasteElement = document.getElementById('waste');
    wasteElement.addEventListener('dragover', (e) => e.preventDefault());
    wasteElement.addEventListener('drop', (e) => handleDrop(e, 'waste'));

    foundations.forEach((_, index) => {
        const foundationElement = document.getElementById(`foundation-${index}`);
        foundationElement.addEventListener('dragover', (e) => e.preventDefault());
        foundationElement.addEventListener('drop', (e) => handleDrop(e, `foundation-${index}`));
    });

    tableau.forEach((_, index) => {
        const tableauElement = document.getElementById(`tableau-${index}`);
        tableauElement.addEventListener('dragover', (e) => e.preventDefault());
        tableauElement.addEventListener('drop', (e) => handleDrop(e, `tableau-${index}`));
    });
}

document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
